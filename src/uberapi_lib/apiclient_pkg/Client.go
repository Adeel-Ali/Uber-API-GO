/*
 * uberapi_lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 05/21/2016
 */
package apiclient_pkg


import(
	"errors"
	"encoding/json"
	"uberapi_lib/models_pkg"
	"github.com/apimatic/unirest-go"
	"uberapi_lib"
	"uberapi_lib/apihelper_pkg"
)

/*
 * Input structure for the method GetProductsTypes
 */
type GetProductsTypesInput struct {
    Latitude        float64         //Latitude component of location.
    Longitude       float64         //Longitude component of location.
}

/*
 * Input structure for the method GetPriceEstimates
 */
type GetPriceEstimatesInput struct {
    StartLatitude   float64         //Latitude component of start location.
    StartLongitude  float64         //Longitude component of start location.
    EndLatitude     float64         //Latitude component of end location.
    EndLongitude    float64         //Longitude component of end location.
}

/*
 * Input structure for the method GetTimeEstimates
 */
type GetTimeEstimatesInput struct {
    StartLatitude   float64         //Latitude component of the start location
    StartLongitude  float64         //Longitude component of the start location
    CustomerUuid    *string         //The customer id interested in estimate
    ProductId       *string         //Id of the requested product
}

/*
 * Input structure for the method GetUserActivityV11
 */
type GetUserActivityV11Input struct {
    Offset          int64           //Page offset for pagging
    Limit           int64           //Number of items to return for pagging
}

/*
 * Input structure for the method GetPromotions
 */
type GetPromotionsInput struct {
    StartLatitude   float64         //Latitude component of start location.
    StartLongitude  float64         //Longitude component of start location
    EndLatitude     float64         //Latitude component of end location.
    EndLongitude    float64         //Longitude component of end location.
}

/*
 * Client structure as interface implementation
 */
type APICLIENT_IMPL struct { }

/**
 * The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
 * @param  GetProductsTypesInput     Structure with all inputs
 * @return	Returns the *models_pkg.ProductCollection response from the API call
 */
func (me *APICLIENT_IMPL) GetProductsTypes (input *GetProductsTypesInput) (*models_pkg.ProductCollection, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/products"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithQueryParameters(_queryBuilder, map[string]interface{} {
        "latitude" : input.Latitude,
        "longitude" : input.Longitude,
    })
    if err != nil {
        //error in query param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.ProductCollection = &models_pkg.ProductCollection{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.
 * @param  GetPriceEstimatesInput     Structure with all inputs
 * @return	Returns the *models_pkg.PriceEstimateCollection response from the API call
 */
func (me *APICLIENT_IMPL) GetPriceEstimates (input *GetPriceEstimatesInput) (*models_pkg.PriceEstimateCollection, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/estimates/price"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithQueryParameters(_queryBuilder, map[string]interface{} {
        "end_latitude" : input.EndLatitude,
        "end_longitude" : input.EndLongitude,
        "start_latitude" : input.StartLatitude,
        "start_longitude" : input.StartLongitude,
    })
    if err != nil {
        //error in query param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.PriceEstimateCollection = &models_pkg.PriceEstimateCollection{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
 * @param  GetTimeEstimatesInput     Structure with all inputs
 * @return	Returns the *models_pkg.TimeEstimateCollection response from the API call
 */
func (me *APICLIENT_IMPL) GetTimeEstimates (input *GetTimeEstimatesInput) (*models_pkg.TimeEstimateCollection, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/estimates/time"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithQueryParameters(_queryBuilder, map[string]interface{} {
        "start_latitude" : input.StartLatitude,
        "start_longitude" : input.StartLongitude,
        "customer_uuid" : input.CustomerUuid,
        "product_id" : input.ProductId,
    })
    if err != nil {
        //error in query param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.TimeEstimateCollection = &models_pkg.TimeEstimateCollection{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.
 * @param  GetUserActivityV11Input     Structure with all inputs
 * @return	Returns the *models_pkg.UserActivity response from the API call
 */
func (me *APICLIENT_IMPL) GetUserActivityV11 (input *GetUserActivityV11Input) (*models_pkg.UserActivity, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1.1/history"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithQueryParameters(_queryBuilder, map[string]interface{} {
        "limit" : input.Limit,
        "offset" : input.Offset,
    })
    if err != nil {
        //error in query param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.UserActivity = &models_pkg.UserActivity{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * The User Profile endpoint returns information about the Uber user that has authorized with the application.
 * @return	Returns the *models_pkg.UserProfile response from the API call
 */
func (me *APICLIENT_IMPL) GetUserProfile () (*models_pkg.UserProfile, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/me"

    //variable to hold errors
    var err error = nil
    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.UserProfile = &models_pkg.UserProfile{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * Get product details w.r.t id
 * @param    string        productId      parameter: Required
 * @return	Returns the *models_pkg.Product response from the API call
 */
func (me *APICLIENT_IMPL) GetProductDetailByID (
            productId string) (*models_pkg.Product, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/products/{product_id}"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithTemplateParameters(_queryBuilder, map[string]interface{} {
        "product_id" : productId,
    })
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
        err = apihelper_pkg.NewAPIError("HTTP Response Not OK" , _response.Code, _response.RawBody)
    }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.Product = &models_pkg.Product{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * The Promotions endpoint returns information about the promotion that will be available to a new user based on their activity's location. These promotions do not apply for existing users.
 * @param  GetPromotionsInput     Structure with all inputs
 * @return	Returns the *models_pkg.PromotionsResponse response from the API call
 */
func (me *APICLIENT_IMPL) GetPromotions (input *GetPromotionsInput) (*models_pkg.PromotionsResponse, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/promotions"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithQueryParameters(_queryBuilder, map[string]interface{} {
        "end_latitude" : input.EndLatitude,
        "end_longitude" : input.EndLongitude,
        "start_latitude" : input.StartLatitude,
        "start_longitude" : input.StartLongitude,
    })
    if err != nil {
        //error in query param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _response.Code, _response.RawBody)
    } else if (_response.Code == 409) {
        err = apihelper_pkg.NewAPIError("A conflict needs to be resolved before the request can be made.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code == 222) {
        err = apihelper_pkg.NewAPIError("bac", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.PromotionsResponse = &models_pkg.PromotionsResponse{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * The Request endpoint allows a ride to be requested on behalf of an Uber user given their desired product, start, and end locations. Please review the Sandbox documentation on how to develop and test against these endpoints without making real-world Requests and being charged.
 * @param    *models_pkg.RequestBody        body     parameter: Required
 * @return	Returns the *models_pkg.Request response from the API call
 */
func (me *APICLIENT_IMPL) CreateRequest (
            body *models_pkg.RequestBody) (*models_pkg.Request, error) {
    //validating required parameters
    if (body == nil){
        return nil,errors.New("The parameter 'body' is a required parameter and cannot be nil.")
}     //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/requests"

    //variable to hold errors
    var err error = nil
    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
        "content-type" : "application/json; charset=utf-8",
    }

    //prepare API request
    _request := unirest.Post(_queryBuilder, headers, body)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json", _response.Code, _response.RawBody)
    } else if (_response.Code == 409) {
        err = apihelper_pkg.NewAPIError("A conflict needs to be resolved before the request can be made.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.Request = &models_pkg.Request{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * Get the real time status of an ongoing trip that was created using the Ride Request endpoint.
 * @param    string        requestId      parameter: Required
 * @return	Returns the *models_pkg.RequestDetailsCollections response from the API call
 */
func (me *APICLIENT_IMPL) GetRequestDetails (
            requestId string) (*models_pkg.RequestDetailsCollections, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/requests/{request_id}"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithTemplateParameters(_queryBuilder, map[string]interface{} {
        "request_id" : requestId,
    })
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found.", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _response.Code, _response.RawBody)
    } else if (_response.Code == 409) {
        err = apihelper_pkg.NewAPIError("A conflict needs to be resolved before the request can be made.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.RequestDetailsCollections = &models_pkg.RequestDetailsCollections{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * Cancel an ongoing Request on behalf of a rider.
 * @param    string        requestId      parameter: Required
 * @return	Returns the  response from the API call
 */
func (me *APICLIENT_IMPL) DeleteRequestCancel (
            requestId string) (error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/requests/{request_id}"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithTemplateParameters(_queryBuilder, map[string]interface{} {
        "request_id" : requestId,
    })
    if err != nil {
        //error in template param handling
        return err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
    }

    //prepare API request
    _request := unirest.Delete(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _response.Code, _response.RawBody)
    } else if (_response.Code == 409) {
        err = apihelper_pkg.NewAPIError("A conflict needs to be resolved before the request can be made", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return err
    }

    //returning the response
    return nil
}

/**
 * Get a map with a visual representation of a Request.
 * @param    string        requestId      parameter: Required
 * @return	Returns the *models_pkg.RequestMapResponse response from the API call
 */
func (me *APICLIENT_IMPL) GetRequestMap (
            requestId string) (*models_pkg.RequestMapResponse, error) {
        //the base uri for api requests
    _queryBuilder := uberapi_lib.BASEURI;

    //prepare query string for API call
   _queryBuilder = _queryBuilder + "/v1/requests/{request_id}/map"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    _queryBuilder, err = apihelper_pkg.AppendUrlWithTemplateParameters(_queryBuilder, map[string]interface{} {
        "request_id" : requestId,
    })
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    _queryBuilder, err = apihelper_pkg.CleanUrl(_queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "APIMATIC 2.0",
        "accept" : "application/json",
    }

    //prepare API request
    _request := unirest.Get(_queryBuilder, headers)
    //and invoke the API call request to fetch the response
    _response, err := unirest.AsString(_request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (_response.Code == 400) {
        err = apihelper_pkg.NewAPIError("Malformed request.", _response.Code, _response.RawBody)
    } else if (_response.Code == 401) {
        err = apihelper_pkg.NewAPIError("Unauthorized the request requires user authentication (not logged in).", _response.Code, _response.RawBody)
    } else if (_response.Code == 403) {
        err = apihelper_pkg.NewAPIError("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues", _response.Code, _response.RawBody)
    } else if (_response.Code == 404) {
        err = apihelper_pkg.NewAPIError("Not found", _response.Code, _response.RawBody)
    } else if (_response.Code == 406) {
        err = apihelper_pkg.NewAPIError("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _response.Code, _response.RawBody)
    } else if (_response.Code == 409) {
        err = apihelper_pkg.NewAPIError("A conflict needs to be resolved before the request can be made.", _response.Code, _response.RawBody)
    } else if (_response.Code == 422) {
        err = apihelper_pkg.NewAPIError("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _response.Code, _response.RawBody)
    } else if (_response.Code == 429) {
        err = apihelper_pkg.NewAPIError("Too Many Requests. Rate limited.", _response.Code, _response.RawBody)
    } else if (_response.Code == 500) {
        err = apihelper_pkg.NewAPIError("Internal Server Error.", _response.Code, _response.RawBody)
    } else if (_response.Code < 200) || (_response.Code > 206) { //[200,206] = HTTP OK
            err = apihelper_pkg.NewAPIError("HTTP Response Not OK", _response.Code, _response.RawBody)
        }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }

    //returning the response
    var retVal *models_pkg.RequestMapResponse = &models_pkg.RequestMapResponse{}
    err = json.Unmarshal(_response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

